import{_ as e,c as a,o as t,a4 as r}from"./chunks/framework.Ci4AqDqK.js";const f=JSON.parse('{"title":"web 安全","description":"","frontmatter":{},"headers":[],"relativePath":"articles/前端/web安全.md","filePath":"articles/前端/web安全.md"}'),o={name:"articles/前端/web安全.md"},i=r('<h1 id="web-安全" tabindex="-1">web 安全 <a class="header-anchor" href="#web-安全" aria-label="Permalink to &quot;web 安全&quot;">​</a></h1><h2 id="xss-跨站脚本攻击" tabindex="-1">XSS 跨站脚本攻击 <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS 跨站脚本攻击&quot;">​</a></h2><p>简单理解：攻击者脚本嵌入被攻击网站，获取用户 cookie 等隐私信息。<br> 解决方案：</p><ol><li>服务器对输入脚本进行过滤或转码</li><li>充分利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noreferrer">CSP</a></li><li>使用 HttpOnly 属性</li></ol><h2 id="csrf-跨站请求伪造" tabindex="-1">CSRF 跨站请求伪造 <a class="header-anchor" href="#csrf-跨站请求伪造" aria-label="Permalink to &quot;CSRF 跨站请求伪造&quot;">​</a></h2><p>简单理解：已登录用户访问攻击者网站，攻击网站向被攻击网站发起恶意请求（利用浏览器会自动携带 cookie）。<br> 解决方案：</p><ol><li>充分利用好 Cookie 的 SameSite 属性</li><li>验证请求的来源站点（Referer、Origin）</li><li>CSRF Token</li></ol>',7),l=[i];function s(c,n,_,d,h,b){return t(),a("div",null,l)}const S=e(o,[["render",s]]);export{f as __pageData,S as default};
